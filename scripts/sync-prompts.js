/* eslint-env node */
const https = require("https");
const fs = require("fs");
const path = require("path");
const prettier = require("prettier");

const SOURCE_URL =
  "https://raw.githubusercontent.com/0x2e-Tech/awesome-ai-prompts/main/README.md";
const OUTPUT_PATH = path.join(
  process.cwd(),
  "client",
  "lib",
  "prompts-data.ts",
);

const fetchText = (url) =>
  new Promise((resolve, reject) => {
    https
      .get(url, (res) => {
        if (res.statusCode && res.statusCode >= 400) {
          reject(new Error(`Request failed with status ${res.statusCode}`));
          res.resume();
          return;
        }
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => resolve(data));
      })
      .on("error", reject);
  });

const slugify = (title, used) => {
  const base =
    title
      .normalize("NFKD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/[^a-zA-Z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "")
      .toLowerCase() || "prompt";

  let slug = base;
  let counter = 2;
  while (used.has(slug)) {
    slug = `${base}-${counter}`;
    counter += 1;
  }
  used.add(slug);
  return slug;
};

const parsePrompts = (markdown) => {
  const sections = markdown.split(/^###\s+/m).slice(1);
  const usedIds = new Set();
  const prompts = [];

  for (const section of sections) {
    const lines = section.split(/\r?\n/);
    const rawTitle = lines[0]?.trim();
    if (!rawTitle) continue;

    const usageMatch = section.match(/\*\*Prompt Usage\*\*:\s*\n`([\s\S]*?)`/);
    if (!usageMatch) continue;

    const promptText = usageMatch[1].trim();
    if (!promptText) continue;

    const tagsMatch = section.match(/\*\*Tags\*\*:\s*`([^`]+)`/);
    const tags = tagsMatch
      ? tagsMatch[1]
          .split(",")
          .map((tag) => tag.trim())
          .filter(Boolean)
      : [];

    const title = rawTitle.replace(/\s+/g, " ").trim();
    const id = slugify(title, usedIds);

    prompts.push({
      id,
      title,
      prompt: promptText,
      category: "Awesome Prompts",
      tags,
    });
  }

  return prompts;
};

const writePromptsFile = async (prompts) => {
  const header =
    "// This file is auto-generated by scripts/sync-prompts.js.\n" +
    "// Do not edit manually.\n\n";
  const body = `export const SYSTEM_PROMPTS = ${JSON.stringify(
    prompts,
    null,
    2,
  )} as const;\n`;
  const prettierConfig = (await prettier.resolveConfig(OUTPUT_PATH)) || {};
  const formatted = await prettier.format(header + body, {
    ...prettierConfig,
    parser: "typescript",
  });
  fs.writeFileSync(OUTPUT_PATH, formatted, "utf8");
};

const main = async () => {
  const markdown = await fetchText(SOURCE_URL);
  const prompts = parsePrompts(markdown);
  if (prompts.length === 0) {
    throw new Error("No prompts parsed from source.");
  }
  await writePromptsFile(prompts);
  console.log(`Synced ${prompts.length} prompts to ${OUTPUT_PATH}`);
};

main().catch((error) => {
  console.error("Prompt sync failed:", error.message || error);
  process.exitCode = 1;
});
